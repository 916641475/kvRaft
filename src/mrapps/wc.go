package main

//
// a word-count application "plugin" for MapReduce.
//
// go build -buildmode=plugin wc.go
//

import (
	"encoding/json"
	"fmt"
	"hash/fnv"
	"io"
	"os"
	"strconv"
	"strings"
	"unicode"

	"6.824/mr"
)

// The map function is called once for each file of input. The first
// argument is the name of the input file, and the second is the
// file's complete contents. You should ignore the input file name,
// and look only at the contents argument. The return value is a slice
// of key/value pairs.
func Map(filename string, contents string) []mr.KeyValue {
	// function to detect word separators.
	ff := func(r rune) bool { return !unicode.IsLetter(r) }

	// split contents into an array of words.
	words := strings.FieldsFunc(contents, ff)

	kva := []mr.KeyValue{}
	for _, w := range words {
		kv := mr.KeyValue{w, "1"}
		kva = append(kva, kv)
	}
	return kva
}

// The reduce function is called once for each key generated by the
// map tasks, with a list of all the values created for that key by
// any map task.
func Reduce(key string, values []string) string {
	// return the number of occurrences of this word.
	return strconv.Itoa(len(values))
}

//

type KVPair struct {
	key   string
	value int
}

func ihash(key string) int {
	h := fnv.New32a()
	h.Write([]byte(key))
	return int(h.Sum32() & 0x7fffffff)
}

func MyMap(filename string, nReduce int) {
	file, _ := os.Open(filename)
	temp, _ := io.ReadAll(file)
	contents := string(temp)

	ff := func(r rune) bool { return !unicode.IsLetter(r) }
	//words := sort.StringSlice(strings.FieldsFunc(contents, ff))
	//sort.Sort(words)
	words := strings.FieldsFunc(contents, ff)
	nmaps := make([]map[string]int, nReduce)
	for _, each := range words {
		var hashcode int = ihash(each)
		_, exist := nmaps[hashcode][each]
		if exist {
			nmaps[hashcode][each]++
		} else {
			nmaps[hashcode][each] = 1
		}
	}

	for i := 0; i < nReduce; i++ {
		var finalfilename, tempfilename string
		finalfilename = fmt.Sprintf("./mr-%s-%d", filename, nReduce)
		_, err := os.Stat(finalfilename)
		if err != nil {
			continue
		}
		tempfilename = fmt.Sprintf("./temp-mr-%s-%d", filename, nReduce)
		fd, _ := os.OpenFile(tempfilename, os.O_RDWR|os.O_CREATE, 0666)
		defer fd.Close()
		encoder := json.NewEncoder(fd)
		var kvpair KVPair
		for key, value := range nmaps[i] {
			kvpair = KVPair{key, value}
			encoder.Encode(&kvpair)
		}
		os.Rename(tempfilename, finalfilename)
	}
}

func MyReduce(reduceN int) {
	files, _ := os.ReadDir(".")
	kvm := make(map[string]int)
	var reduceNs string = strconv.Itoa(reduceN)
	for _, file := range files {
		if strings.HasSuffix(file.Name(), reduceNs) {
			fd, _ := os.OpenFile(file.Name(), os.O_RDWR|os.O_CREATE, 0666)
			decoder := json.NewDecoder(fd)
			for {
				var kvpair KVPair
				if err := decoder.Decode(&kvpair); err != nil {
					break
				}
				if _, exist := kvm[kvpair.key]; exist {
					kvm[kvpair.key] = kvm[kvpair.key] + kvpair.value
				} else {
					kvm[kvpair.key] = kvpair.value
				}
			}
			fd.Close()
		}
	}

	fd, _ := os.OpenFile(fmt.Sprintf("mr-out-%d", reduceN), os.O_RDWR|os.O_CREATE, 0666)
	defer fd.Close()
	for key, value := range kvm {
		fmt.Fprintf(fd, "%s %d\n", key, value)
	}
}
